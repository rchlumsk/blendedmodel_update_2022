---
title: "Blended model configuration update - analysis of results"
author: "R. Chlumsky, J. Mai, J. R. Craig, B. A. Tolson"
date: "2023-06-09"
output: html_document
editor_options: 
  chunk_output_type: console
---

This Rmd file contains the code chunks (scripts) required to generate the figures in the manuscript for the updated blended model configuration study.

# Setup Chunks

## Setting Options and Loading Libraries

```{r setup options, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message=FALSE)
library(knitr)
library(kableExtra)
options(warn = -1) 
options(stringsAsFactors = F)
options(pillar.sigfig = 5)
```

```{r load libraries}
library(RavenR)
library(xts)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(ggpubr)
library(purrr)
library(scales)
library(gridExtra)
library(sf)
library(maps)
library(rnaturalearth)
library(rnaturalearthdata)
library(ggspatial)
library(ggdist)
library(ggrepel)
library(forcats)
```

## Additional Function Declarations

```{r additional support functions for producing figures}
ggplotColours <- function(n = 6, h = c(0, 360) + 15){
  if ((diff(h) %% 360) < 1) h[2] <- h[2] - 360/n
  hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
}

process_names <- list(
  'snowbalance'="snow balance",
  'quickflow'="quickflow",
  'evapotranspiration'="evapotranspiration",
  'baseflow'="baseflow",
  'infiltration'='infiltration',
  'ET'='ET'
  )

process_labeller <- function(variable,value){
return(process_names[value])
}

process_labeller_mopex <- function(variable,value) {
  # sprintf("MOPEX ID: %s", basins_chars$basin_id[value]) %>% 
  # sprintf("MOPEX %i", value) %>% 
  sprintf("MPX %i (%s)", value, basins_chars_2$state_full[value]) %>% 
  return()
}

labeller_watershedID_type <- function(variable,value) {
  # sprintf("MOPEX ID: %s", basins_chars$basin_id[value]) %>% 
  # sprintf("MOPEX %i", value) %>% 
  if (value %in% seq(1,12)) {
    lbl <- sprintf("MPX %i (%s)", value, basins_chars_2$state_full[value])
  } else {
    lbl <- as.character(value)
  }
   
  return(lbl)
}

labeller_watershedID_type_2 <- function(variable,value) {
  # sprintf("MOPEX ID: %s", basins_chars$basin_id[value]) %>% 
  # sprintf("MOPEX %i", value) %>% 
  if (value %in% seq(13,24)) {
    lbl <- sprintf("Basin ID %s (%s)", basins_chars_2$basin_id[value], basins_chars_2$state_full[value])
  } else {
    lbl <- as.character(value)
  }
   
  return(lbl)
}

labeller_process_modelv <- function(variable,value) {
  if (is.integer(value)) {
    lbl <- sprintf("blend_v%i", value)
  } else {
    lbl <- as.character(value)
  }
  return(lbl)
}

labeller_calib_valid <- function(variable,value) {
  lbl <- gsub("_",replacement=" ",x=value)
  if (lbl[1]=="calib kge") {
    lbl[1] <- "Calibration KGE"
  } else {
    lbl[1] <- "Validation KGE"
  }
  
  if (lbl[2]=="calib kge") {
    lbl[2] <- "Calibration KGE"
  } else {
    lbl[2] <- "Validation KGE"
  }
  return(lbl)
}

scale_override <- function(which, scale) {
  if(!is.numeric(which) || (length(which) != 1) || (which %% 1 != 0)) {
    stop("which must be an integer of length 1")
  }
  
  if(is.null(scale$aesthetics) || !any(c("x", "y") %in% scale$aesthetics)) {
    stop("scale must be an x or y position scale")
  }
  
  structure(list(which = which, scale = scale), class = "scale_override")
}

CustomFacetWrap <- ggproto(
  "CustomFacetWrap", FacetWrap,
  init_scales = function(self, layout, x_scale = NULL, y_scale = NULL, params) {
    # make the initial x, y scales list
    scales <- ggproto_parent(FacetWrap, self)$init_scales(layout, x_scale, y_scale, params)
    
    if(is.null(params$scale_overrides)) return(scales)
    
    max_scale_x <- length(scales$x)
    max_scale_y <- length(scales$y)
    
    # ... do some modification of the scales$x and scales$y here based on params$scale_overrides
    for(scale_override in params$scale_overrides) {
      which <- scale_override$which
      scale <- scale_override$scale
      
      if("x" %in% scale$aesthetics) {
        if(!is.null(scales$x)) {
          if(which < 0 || which > max_scale_x) stop("Invalid index of x scale: ", which)
          scales$x[[which]] <- scale$clone()
        }
      } else if("y" %in% scale$aesthetics) {
        if(!is.null(scales$y)) {
          if(which < 0 || which > max_scale_y) stop("Invalid index of y scale: ", which)
          scales$y[[which]] <- scale$clone()
        }
      } else {
        stop("Invalid scale")
      }
    }
    
    # return scales
    scales
  }
)

facet_wrap_custom <- function(..., scale_overrides = NULL) {
  # take advantage of the sanitizing that happens in facet_wrap
  facet_super <- facet_wrap(...)
  
  # sanitize scale overrides
  if(inherits(scale_overrides, "scale_override")) {
    scale_overrides <- list(scale_overrides)
  } else if(!is.list(scale_overrides) || 
            !all(vapply(scale_overrides, inherits, "scale_override", FUN.VALUE = logical(1)))) {
    stop("scale_overrides must be a scale_override object or a list of scale_override objects")
  }
  
  facet_super$params$scale_overrides <- scale_overrides
  
  ggproto(NULL, CustomFacetWrap,
          shrink = facet_super$shrink,
          params = facet_super$params
  )
}
```

## Read Summarized Results

```{r read in results}
master_table_new <- read.csv("results_data_tabulated/summarized_results_performance_20230609.csv")

master_params <- read.csv("results_data_tabulated/summarized_results_parameters_20230609.csv")

master_weights <- read.csv("results_data_tabulated/summarized_results_weights_20230609.csv")
```


```{r reformat old and new into one simple dataframe}

mtbl <-
  master_table_new %>% 
  as_tibble() %>%
  dplyr::select(modelversion,watershedID,iteration,ends_with("kge")) %>%
  pivot_longer(cols=ends_with("kge"), names_to="type", values_to="kge_metric") %>%
  dplyr::select(modelversion, watershedID, iteration, kge_metric, type)

```


```{r filter data frames and prepare max_tbl}
models_all <- c(seq(0,23),24,29,30, seq(33,37))
models_for_paper <- c(seq(0,23),29,30, seq(33,37)) # for paper

mtbl <- mtbl %>% 
  filter(modelversion %in% models_all) %>% 
  mutate(modelversion = as.factor(modelversion))

master_weights <- master_weights %>% 
  filter(modelversion %in% models_all) %>% 
  mutate(modelversion = as.factor(modelversion))

# max calib and associated valid
max_tbl <- mtbl %>% 
  pivot_wider(values_from=kge_metric, names_from=type) %>% 
  group_by(watershedID,modelversion) %>% 
  filter(calib_kge == max(calib_kge)) %>% 
  pivot_longer(cols=c(calib_kge,valid_kge),
               values_to = "kge_metric", names_to="type")

## for modelversion==0 and watershedID==14, two trials with exact same calibration KGE to 6 digits
## take one with higher validation (iteration 5 validation is higher than 15)

# look for duplicates
max_tbl %>% 
  group_by(modelversion,watershedID,type,kge_metric) %>% 
  filter(n()>1)

# remove max_tbl with iteration 15 for watershedID 14 and modelversion 0 (the lower validation score)
max_tbl <- max_tbl[-(which(max_tbl$modelversion == 0 & max_tbl$watershedID==14 & max_tbl$iteration==15)),]


validgap_tbl <-
  tidyr::pivot_wider(data=max_tbl, names_from=type, values_from=kge_metric) %>% 
 mutate(validgap = calib_kge-valid_kge)

# mean diff in max calib KGE and mean calib KGE
temp <- mtbl %>% 
  filter(type=="calib_kge") %>% 
    group_by(modelversion,watershedID) %>% 
    summarise(mean_calib_kge = mean(kge_metric))

meandiff_tbl <- max_tbl %>%
  filter(type=="calib_kge") %>% 
  mutate(max_kge = kge_metric) %>% 
  merge(x=., y=temp, by=c("modelversion", "watershedID"))
  
meandiff_tbl$meandiff <- meandiff_tbl$max_kge - meandiff_tbl$mean_calib_kge

perftbl <- merge(x=validgap_tbl, y=meandiff_tbl, by=c("modelversion", "watershedID"))
```

# MOPEX12 Catchments

## MOPEX12 Map

```{r MOPEX characteristics}
world <- ne_countries(scale = "medium", returnclass = "sf")
states <- st_as_sf(map("state", plot = FALSE, fill = TRUE))

basins_chars <- read.table("../setup/basin_physical_characteristics.txt", sep=";", header = TRUE)

basins_chars %>% 
  mutate(catchid = row_number()) %>% 
  mutate(state = RavenR::rvn_substrRight(basin_name,2)) ->
  basins_chars_2

basins_chars_2$basin_name <- str_to_title(basins_chars_2$basin_name)

basins_chars_2$state_full <- c("West Virginia","Maryland","Virginia","West Virginia","West Virginia","Indiana","North Carolina",
    "Idaho","Missouri","Louisiana","Texas","Texas",
    rep(NA,24))
# 
#     "Maine","Conneticut","New York","Mississippi","Tennessee","Utah",
#     "California","California","California","Idaho","Idaho","Idaho",
#      "Virginia","Georgia","Florida","Kentucky","Ohio","Wisconsin",
#     "Illinois","Kansas","Idaho","Arkansas","Kansas","Oregon")
basins_chars_2$basin_id <- sprintf("%08d", basins_chars_2$basin_id)
basins_chars_2$basin_name <- toupper(basins_chars$basin_name)
```

```{r read in additional properties for each catchment}
df <- read.csv("../setup/basin_hydrologic_characteristics.csv")
basins_chars_2 <- cbind(basins_chars_2,df)
rm(df)
```


```{r manuscript figure - MOPEX map with new basins (Figure 1)}

## plot map of randomly selected additional stations
p1 <- world %>% 
  filter(continent == "North America") %>% 
  ggplot(data = .) +
  geom_sf() +
  geom_sf(data = states, fill = NA, size=0.1) + 
  xlab("Longitude") + ylab("Latitude") +
  geom_point(data=basins_chars_2, aes(x=lon, y=lat, fill=basintype, shape=basintype), color='black',size=2)+
  scale_fill_manual(values=c("red","purple"), breaks=c("MOPEX","NEWCATCHMENTS"), name="",
                    labels=c("MOPEX12 catchments",
                             "Additional independent catchments"))+
  scale_shape_manual(values=c(21,22), breaks=c("MOPEX","NEWCATCHMENTS"), name="",
                    labels=c("MOPEX12 catchments",
                             "Additional independent catchments"))+
  annotation_north_arrow(location = "bl", which_north = "true", 
                         style = north_arrow_fancy_orienteering) +
  geom_label_repel(data=basins_chars_2, aes(x=lon, y=lat),
                   label = sprintf("%s (%i)",basins_chars_2$state, basins_chars_2$catchid),
                   box.padding=0.5, fill="white", force=2.5,
                   size=2, max.overlaps =36,
                   nudge_y = c(rep(0,22),0.4,0),
                   color="black") +
  coord_sf(xlim = c(-125, -65), ylim = c(25, 50), expand = FALSE)+ 
  theme(legend.position = "bottom", legend.direction = 'horizontal')
  
p1

p1 %>% 
  ggsave("figures/selected_random_catchments_20230609.pdf", plot=., width=6, height=5)
```

```{r manuscript table - properties for newly selected stations (Table 1)}
basins_chars_2[1:36,] %>% 
  
  select(catchid, basin_id, state,area_km2, elevation_m, 
         annual_average_precip_mm, annual_average_PET_mm,
         annual_avg_streamflow_mm,runoff_ratio) %>% 
  kable(., 
        digits=c(0,0,0,0,0,0,0,0,2), # digits doesn't work once converted to kable highlighting
        align='rrcc',
        format="latex",
        escape=FALSE,
        caption="test caption") %>% 
  kable_minimal(full_width=FALSE)
```


# Results 

## Overall performance of blended model configurations

```{r overview performance}

# average improvement over original model in MOPEX basins
mtbl %>% 
  arrange(modelversion,watershedID,iteration,type) %>% 
  group_by(watershedID,modelversion,type) %>% 
  filter(modelversion %in% c(0,36)) %>%
  filter(watershedID %in% seq(1,12)) %>%
  arrange(modelversion,watershedID,type) %>% 
  group_by(modelversion,type) %>%
  summarise(mean_kge=mean(kge_metric)) %>%
  data.frame()

# average improvement over original model in 12 new basins
mtbl %>% 
  arrange(modelversion,watershedID,iteration,type) %>% 
  group_by(watershedID,modelversion,type) %>% 
  filter(modelversion %in% c(0,36)) %>%
  filter(watershedID %in% seq(13,24)) %>%
  arrange(modelversion,watershedID,type) %>% 
  group_by(modelversion,type) %>%
  summarise(mean_kge=mean(kge_metric)) %>%
  data.frame()

# mean and max overall calibration performances
mtbl %>% 
  arrange(modelversion,watershedID,iteration,type) %>% 
  group_by(modelversion,type) %>% 
  filter(modelversion %in% c(26,29)) %>%
  
  # filter(type=="calib_kge") %>% 
  summarise(mean_kge=mean(kge_metric), max_kge=max(kge_metric))

# mean/sd of max performances in each catchment
max_tbl %>% 
  filter(type=="calib_kge") %>% 
  group_by(modelversion) %>% 
  summarise(mean_kge = mean(kge_metric), min_kge=min(kge_metric), max_kge = max(kge_metric), sd_kge=sd(kge_metric)) %>% 
  data.frame()

# performance overall for given model
max_tbl %>% 
  filter(modelversion %in% c(34,36,37)) %>%
  group_by(modelversion,type) %>% 
  summarise(mean_kge = mean(kge_metric), max_kge = max(kge_metric), min_kge=min(kge_metric), sd_kge=sd(kge_metric))
 
# performance of models 0 and 36 in new catchments
mtbl %>% 
  filter(modelversion %in% c(0,36)) %>% 
  filter(watershedID %in% seq(1,12)) %>% 
  group_by(modelversion,watershedID,type) %>% 
  summarise(mean_kge = mean(kge_metric), max_kge = max(kge_metric), min_kge=min(kge_metric), sd_kge=sd(kge_metric)) %>% 
  group_by(modelversion, type) %>% 
  summarize(meanmean = mean(mean_kge), meanmax = mean(max_kge)) %>% 
  as.data.frame()

```


```{r manuscript figures - overall performance (Figures 2 and 3)}
## unranked model performance by version (Figure 2)
p13 <-
  perftbl %>%
  filter(modelversion %in% models_all) %>%
  filter(watershedID %in% seq(1,12)) %>%
    group_by(modelversion) %>%
    summarise(mean_validgap=mean(validgap), mean_meandiff = mean(meandiff), mean_valid_kge = mean(valid_kge),
              mean_maxkge=mean(max_kge), mean_mean_calib_kge=mean(mean_calib_kge)) %>%
    pivot_longer(cols = c(mean_maxkge,mean_valid_kge), names_to="metric_type", values_to="metric_value") %>%
  ggplot(aes(x=as.factor(modelversion), y=metric_value, group=metric_type, color=metric_type))+
    geom_point(aes(shape=metric_type))+
    geom_line()+
    xlab("Model Configuration")+
    ylab("KGE")+
    ylim(c(0.7,0.95))+
    scale_color_manual(name="Metric",
                       values=c('black','orange'),
                       labels=c("max calib\nKGE (avg)", "valid\nKGE (avg)"))+
    scale_shape_manual(name="Metric",
                       values=as.factor(c(1,2)),
                       labels=c("max calib\nKGE (avg)", "valid\nKGE (avg)"))+
  theme(legend.position = 'bottom')
    
p13

p13 %>% 
  ggsave(filename="figures/performance_maxcalib_valid_bymodelversion_notranked_20220413.pdf",
         plot=.,
         units="in", height=4, width=7)


## calibration kge with validation points (Figure 3) ----
models_temp <- c(0,2,3,7,15,24,29,36)

p6 <-
  mtbl %>% 
  filter(type == "calib_kge") %>%
  # filter watersheds
  filter(watershedID %in% seq(1,12)) %>%
  mutate(name = fct_reorder(modelversion, desc(as.numeric(modelversion)))) %>%
  
  filter(modelversion %in% models_temp) %>%
  filter(watershedID %in% seq(1,12)) %>%
  ggplot() +
  geom_boxplot(aes(x=kge_metric, y=modelversion, fill= modelversion), alpha=0.4 )+
  geom_point(data=max_tbl[max_tbl$type=="valid_kge" & max_tbl$modelversion %in% models_temp & max_tbl$watershedID %in% seq(1,12),], 
             aes(x=kge_metric, y=modelversion), # , colour=as.factor(type)
             size=1.5, shape=23, fill='orange', colour='black')+
  facet_wrap(~watershedID,  ncol=4, scales="free", labeller = labeller_watershedID_type)+ # 
  xlab("KGE") + 
  scale_fill_manual(name="Model\nConfiguration",
                    labels=sprintf("model_v%i",models_temp),
                    values=ggplotColours(n=length(models_temp)))+
  scale_colour_manual(name="",labels=c("KGE VALID\n(from best calib)"))+
  theme(legend.position = "none")+
  ylab("Model Configuration")+
  xlim(c(0.55,0.95))

p6
 
p6 %>% 
  ggsave(filename="figures/performance_calib_modelv0-37xlimfixed_select_20230811.pdf", plot=.,
         units="in", height=5.5, width=7)
```

## Overfitting analysis

```{r get number of params for each modelverison}

tied_param_cols <- master_params %>% 
  filter(watershedID==1) %>% 
  select(-c(watershedID,iteration)) %>% 
  select(-contains('sum')) %>% 
  select(-contains('nw')) %>% 
  select(-contains('half')) %>% 
  select(-contains('pow')) %>% 
  select(-contains('prod')) %>% 
  select(-contains('ratio'))
      
tied_param_cols %>% 
  group_by(modelversion)

not_all_na <- function(x) any(!is.na(x))

param_nums <- data.frame(matrix(NA,
                          nrow=length(unique(master_params$modelversion)),
                          ncol=2))
names(param_nums) <- c("modelversion","param_count")
param_nums$modelversion <- unique(master_params$modelversion)


for (i in unique(master_params$modelversion) ) {
  param_nums[param_nums$modelversion == i,2] <- tied_param_cols %>% 
            filter(modelversion == i) %>% 
             select(where(not_all_na)) %>% 
              select(-modelversion) %>% 
                ncol()
}

# add in conglomerate model 24 manually
param_nums <- rbind(param_nums, c(24,79))
param_nums <- param_nums[param_nums$modelversion %in% c(models_for_paper,24),]
param_nums <- param_nums[order(param_nums$modelversion),]

param_nums

write.csv(param_nums,
          "param_counts_by_modelversion.csv",
          quote=FALSE, row.names = FALSE)

```


```{r manuscript figures and analysis - overfitting check (Figure 4, Tables 2)}

# note that modelversion 24 (conglomerate model) excluded
param_nums <- param_nums[param_nums$modelversion %in% models_for_paper,]
param_nums$modelversion <- as.factor(param_nums$modelversion)
param_data <- left_join(max_tbl, param_nums, by="modelversion")

param_data$watershedID <- as.factor(param_data$watershedID)

param_data <- param_data %>% 
  filter(watershedID %in% seq(1,12)) %>% 
  filter(modelversion %in% models_for_paper)

fit <- param_data %>% 
  filter(type == "valid_kge") %>% 
  lm(kge_metric ~ param_count, data=.)

summary(fit)

p3 <-
  param_data %>% 
  filter(type == "valid_kge") %>% 
    ggplot(aes(x=param_count, y=kge_metric))+
  geom_point(data=param_data, color='black', alpha=0.5)+
  geom_smooth(method = "lm")+  # , se=FALSE
  theme(legend.position="none")+
  ylab("Validation KGE")+
  xlab("Number of Calibrated Parameters")

p3

ggsave(sprintf("figures/kge_paramcount_notoverfit_20230118.pdf") ,
                 plot=p3,units="in", height=4, width=5)

## statistical tests for each model watershed

run_regression_bywatershed <- function(df=NULL, watershed=1) {
  
  temp <- df %>% 
   filter(type == "valid_kge") %>% 
  filter(watershedID == watershed)

  fit <- lm(kge_metric ~ param_count, data=temp)
  
  rv <-  data.frame(t(c(coef(fit), summary(fit)$coefficients[2,4])))
  colnames(rv) <- c("intercept","slope","slope_pvalue")
  
  return(rv)
}

dd <- lapply(1:12, function(x) run_regression_bywatershed(df=param_data, watershed=x)) 
dd <- as.data.frame(do.call(rbind,dd))
dd$watershedID <- seq(1,12)
dd$watershed_desc <- sprintf("%s (%s)", basins_chars_2$basin_id[1:12], basins_chars_2$state_full[1:12])

formatv <- function(x, ...) {
  mapply(format, x, scientific = abs(x) < 1e-2, digits=3, width=4, ...)
} 

## make nice table
temp <- dd %>% 
  select(watershedID, watershed_desc, slope, intercept, slope_pvalue ) 

temp[,c(3:5)] <- lapply(temp[,c(3:5)], formatv) 
temp

temp %>% 
 kable(., 
        digits=3, 
        align='rccc',
        format="latex",
        escape=FALSE,
        caption="test caption") %>% 
  kable_minimal(full_width=FALSE)
```

```{r manuscript figures and analysis for delta KGE - overfitting check (Table 3)}

# delta KGE version

param_nums$modelversion <- as.factor(param_nums$modelversion)
param_data <- left_join(validgap_tbl, param_nums, by="modelversion")

param_data$watershedID <- as.factor(param_data$watershedID)

param_data <- param_data %>% 
  filter(watershedID %in% seq(1,12)) %>% 
  filter(modelversion %in% models_for_paper)

fit <- param_data %>% 
  lm(validgap ~ param_count, data=.)

summary(fit)

p4  <-
  param_data %>% 
    ggplot(aes(x=param_count, y=validgap))+
  geom_point(data=param_data, color='black', alpha=0.5)+
  geom_smooth(method = "lm")+  # , se=FALSE
  theme(legend.position="none")+
  ylab("Validation Gap")+
  xlab("Number of Calibrated Parameters")

p4

## figure not used in paper, but can be exported here
# p4 %>% 
# ggsave(sprintf("figures/validgap_paramcount_notoverfit_20230118.pdf") ,
#                  plot=.,units="in", height=4, width=5)



## statistical tests for each model watershed

run_regression_bywatershed <- function(df=NULL, watershed=1) {
  
  temp <- df %>% 
  filter(watershedID == watershed)

  fit <- lm(validgap ~ param_count, data=temp)
  
  rv <-  data.frame(t(c(coef(fit), summary(fit)$coefficients[2,4])))
  colnames(rv) <- c("intercept","slope","slope_pvalue")
  
  return(rv)
}

dd <- lapply(1:12, function(x) run_regression_bywatershed(df=param_data, watershed=x)) 
dd <- as.data.frame(do.call(rbind,dd))
dd$watershedID <- seq(1,12)
dd$watershed_desc <- sprintf("%s (%s)", basins_chars_2$basin_id[1:12], basins_chars_2$state_full[1:12])

formatv <- function(x, ...) {
  mapply(format, x, scientific = abs(x) < 1e-2, digits=3, width=4, ...)
} 

## make nice table
temp <- dd %>% 
  select(watershedID, watershed_desc, slope, intercept, slope_pvalue ) 

temp[,c(3:5)] <- lapply(temp[,c(3:5)], formatv) 
temp

temp %>% 
 kable(., 
        digits=3,
        align='rccc',
        format="latex",
        escape=FALSE,
        caption="test caption") %>% 
  kable_minimal(full_width=FALSE)

```


## Pareto evaluation of model versions

```{r manuscript figure - pareto evaluation of model versions (Figure 5)}

temp <- perftbl %>% 
    filter(watershedID %in% seq(1,12)) %>% 
    filter(modelversion %in% models_for_paper) %>% 
    group_by(modelversion) %>% 
    summarise(mean_validgap=mean(validgap), mean_meandiff = mean(meandiff),
              mean_maxkge=mean(max_kge), mean_mean_calib_kge=mean(mean_calib_kge))

pareto <- temp %>% 
  filter(modelversion %in% c(36,37,34,29,30))

p10 <-
  ggplot(data=temp, aes(x=mean_validgap, y=mean_meandiff))+ 
    geom_point()+
    geom_point(data=pareto, size=3)+
    geom_text_repel(aes(label=modelversion),
      size=3,
      arrow = NULL,
      min.segment.length = 5,
      force=0.1,
      box.padding = 0.25
    )+
    xlab("Validation Gap (max KGE calib - valid)")+
    ylab("Calibration Consistency (max KGE - mean KGE)")+
  geom_line(data=pareto, aes(x=mean_validgap, y=mean_meandiff), color='black', linetype='dashed')+
    theme(legend.position='none')+
    xlim(c(0.10,0.14))+  
    ylim(c(0.00,0.04))  

p10

## by average max calib KGE and average valid KGE
temp <- perftbl %>% 
  filter(watershedID %in% seq(1,12)) %>% 
    filter(modelversion %in% models_for_paper) %>% 
  group_by(modelversion) %>% 
    summarise(mean_max_calib_kge=mean(calib_kge), 
              mean_valid_kge=mean(valid_kge)) 

pareto <- 
  temp %>% filter(modelversion == 36)

p12 <-
  ggplot(data=temp, aes(x=mean_valid_kge, y=mean_max_calib_kge))+ 
    geom_point()+
    geom_point(data=pareto, size=3)+
    geom_text_repel(aes(label=modelversion),
          size=3,
          arrow = NULL,
          force=0.1,
          box.padding = 0.25
    )+
    xlab("Mean Validation KGE")+
    ylab("Mean of Max Calibration KGE")+
    theme(legend.position='none')+
    scale_x_reverse(limits=c(0.825,0.725))+
    scale_y_reverse(limits=c(0.925,0.825))

p12


p10 <- p10 + 
 annotate("text",x=-Inf,y=Inf,label="(A)",fontface="bold",size=6, hjust=-0.1,vjust=1.2)

p12 <- p12 + 
 annotate("text",x=Inf,y=-Inf,label="(B)",fontface="bold",size=6, hjust=-0.1,vjust=1.2)

## p10 and p12 in one pareto type plot
list(p10,p12) %>% 
 ggarrange(plotlist=., align='v', ncol=1, common.legend=FALSE) %>% 
  ggsave(sprintf("figures/performance_pareto_combined_20230308.pdf") ,
                 plot=.,units="in", height=8, width=5.5)
```

# Evaluation for new catchments

## Evaluation of selected model version for new catchments

```{r comparison for newcatchments (Figure 6)}
models_temp <- c(0,36)
p16 <-
  mtbl %>% 
  # filter(type == "calib_kge") %>%
  mutate(name = fct_reorder(modelversion, desc(as.numeric(modelversion)))) %>%
  
  filter(modelversion %in% models_temp) %>%
  filter(watershedID %in% seq(13,36)) %>%
  ggplot() +
  stat_slab(aes(y=kge_metric, x=as.factor(watershedID), fill= modelversion))+
  facet_wrap(~type,  nrow=2, scales="free",
             labeller=labeller_calib_valid)+ 
  xlab("Watershed Index") + 
  scale_fill_manual(name="Model\nConfiguration",
                    labels=sprintf("Config. %i",models_temp),
                    values=c("#481568FF","#94D840FF"))+
  ylim(c(0.5,0.95))+
  theme(legend.position = "bottom")+
  ylab("KGE")

p16

p16 %>% 
  ggsave(filename="figures/performance_calib_newcatchments_modelv0_modelv36_xlimfixed_dists_20230609.pdf", plot=.,
         units="in", height=5.5, width=7)
```


```{r Wilcoxon rank sum test for calib and valid KGE in new catchments (Appendix Table A4)}
models_temp <- c(0,36)
dd <-
  mtbl %>% 
  # filter(type == "calib_kge") %>%
  mutate(name = fct_reorder(modelversion, desc(as.numeric(modelversion)))) %>%
  
  filter(modelversion %in% models_temp) %>%
  filter(watershedID %in% seq(13,36))


df <- data.frame(matrix(NA,nrow=length(rep(seq(13,36),2)),ncol=5))
colnames(df) <- c("watershedID","kgetype", "median_0","median_36","pval")

# c("watershedID","kgetype", "median_0_calib","median_36_calib","pval_lt_calib",
#   "median_0_valid","median_36_valid","pval_lt_valid")

df$watershedID <- rep(seq(13,36),2)
df$kgetype <- rep(unique(dd$type),each=nrow(df)/length(unique(dd$type)))

for (i in 1:nrow(df)) {
    
    x <- dd %>% 
      filter(watershedID == df[i,]$watershedID) %>% 
      filter(type==df[i,]$kgetype) %>%  
      filter(modelversion==0) %>% 
      select(kge_metric) %>% 
      unlist() %>% 
      as.numeric()
    
    y <- dd %>% 
      filter(watershedID == df[i,]$watershedID) %>% 
      filter(type==df[i,]$kgetype) %>%  
      filter(modelversion==36) %>% 
      select(kge_metric) %>% 
      unlist() %>% 
      as.numeric()
    
    # structure has x < y
    wtest <- wilcox.test(x=x,y=y,alternative='t',
                exact=TRUE, paired=FALSE, conf.level=0.95)
    
      
    df[i,]$median_0 <- median(x)
    df[i,]$median_36 <- median(y)
    df[i,]$pval <- wtest$p.value
}

nrow(df[df$kgetype=="calib_kge" & df$pval <0.05 & df$median_0 < df$median_36,]) # 0 < 36 in 16 for calib
nrow(df[df$kgetype=="valid_kge" & df$pval <0.05 & df$median_0 < df$median_36,]) # 0 < 36 in 16 for valid
nrow(df[df$kgetype=="calib_kge" & df$pval <0.05 & df$median_0 > df$median_36,]) # 0 > 36 in 2 for calib
nrow(df[df$kgetype=="valid_kge" & df$pval <0.05 & df$median_0 > df$median_36,]) # 0 > 36 for 3 in valid

df

# df %>% 
#   write.csv("temp_wilcoxon_results.csv",
#             quote=FALSE,row.names=FALSE)

formatv <- function(x, ...) {
  mapply(format, x, scientific = abs(x) < 1e-2, digits=3, width=4, ...)
} 

## make nice table
temp <- df %>% 
  select(-kgetype) 

temp[,c(2:4)] <- lapply(temp[,c(2:4)], formatv) 
temp

df %>% 
  select(-kgetype) %>% 
  dplyr::mutate_if(is.numeric, funs(as.character(format(., digits=3)))) %>% 
  # select(-kgetype) %>% 
  kable(., 
        digits=3, # digits doesn't work once converted to kable highlighting
        align='rrcc',
        format="latex",
        escape=FALSE,
        caption="test caption") %>% 
  kable_minimal(full_width=FALSE)
  
```

```{r setup additional columns to test for calib and valid period differences}

basins_chars_2$peak_flow_diff <- basins_chars_2$peak_flow_valid - basins_chars_2$peak_flow_calib
basins_chars_2$peak_flow_diff_onesided <- unlist(lapply(basins_chars_2$peak_flow_diff, FUN=function(x) max(x,0)))

basins_chars_2$annual_flow_diff <- basins_chars_2$annual_avg_flow_valid -  basins_chars_2$annual_avg_flow_calib

basins_chars_2$annual_precip_diff <- basins_chars_2$annual_avg_precip_valid - basins_chars_2$annual_avg_precip_calib

basins_chars_2$peak_daily_precip_diff <- basins_chars_2$peak_daily_precip_valid - basins_chars_2$peak_daily_precip_calib

```


```{r KGE metrics and catchment characteristics regressions for just modelv 36 (Section 3.1 discussion)}

temp_maxcalib <- max_tbl %>% 
  filter(type=="calib_kge") %>% 
  filter(modelversion==36) %>% 
  cbind(basins_chars_2)

temp_validgap <- validgap_tbl %>% 
  filter(modelversion==36) %>% 
  cbind(basins_chars_2)

temp_maxvalid <- max_tbl %>% 
  filter(type=="valid_kge") %>% 
  filter(modelversion==36) %>% 
  cbind(basins_chars_2)

temp_perftbl <- perftbl %>% 
  filter(modelversion == 36) %>% 
  cbind(basins_chars_2)

variables_to_test <- colnames(basins_chars_2)[c(3:8,13:19,28:32)]

dfstat <- data.frame(matrix(NA,nrow=length(variables_to_test),ncol=9))
colnames(dfstat) <- c("dependent_variable","max_calib_KGE_slope","max_calib_KGE_pvalue","validgap_slope","validgap_pvalue","max_valid_KGE_slope","max_valid_KGE_pvalue","calib_consistency_slope","calib_consistency_KGE_pvalue")
dfstat$dependent_variable <- variables_to_test

plotlist <- list()
kk <- 1

for (i in 1:length(variables_to_test)) {

  f1 <- as.formula(sprintf("kge_metric ~ %s",variables_to_test[i]))
  f2 <- as.formula(sprintf("validgap ~ %s",variables_to_test[i]))
  f3 <- as.formula(sprintf("kge_metric ~ %s",variables_to_test[i]))
  f4 <- as.formula(sprintf("meandiff ~ %s",variables_to_test[i]))
  
  ## max calib
  fit <- lm(f1, data=temp_maxcalib)
  dfstat$max_calib_KGE_slope[i] <- fit$coefficients[2]
  dfstat$max_calib_KGE_pvalue[i] <- summary(fit)$coefficients[2,4]
  
  xx <- as.numeric(unlist(temp_maxcalib[,variables_to_test[i]]))
  yy <- temp_maxcalib$kge_metric
  p1 <- data.frame("xx"=xx,"yy"=yy) %>% 
    ggplot(aes(xx,yy))+
    stat_summary(fun.data= mean_cl_normal) + 
    geom_smooth(method='lm')+
    xlab(variables_to_test[i])+
    ylab("Calibration KGE")+
    ggtitle(sprintf("pvalue=%0.4g, slope=%0.4g",
                     dfstat$max_calib_KGE_pvalue[i], dfstat$max_calib_KGE_slope[i]))+
    theme(plot.title = element_text(size=6))
  plotlist[[kk]] <- p1
  kk <- kk+1
  
  ## valid gap
  fit <- lm(f2, data=temp_validgap)
  dfstat$validgap_slope[i] <- fit$coefficients[2]
  dfstat$validgap_pvalue[i] <- summary(fit)$coefficients[2,4]
  xx <- as.numeric(unlist(temp_validgap[,variables_to_test[i]]))
  yy <- temp_validgap$validgap
  p2 <- data.frame("xx"=xx,"yy"=yy) %>% 
    ggplot(aes(xx,yy))+
    stat_summary(fun.data= mean_cl_normal) + 
    geom_smooth(method='lm')+
    xlab(variables_to_test[i])+
    ylab("Validation Gap")+
    ggtitle(sprintf("pvalue=%0.4g, slope=%0.4g",
                     dfstat$validgap_pvalue[i], dfstat$validgap_slope[i]))+
    theme(plot.title = element_text(size=6))
  plotlist[[kk]] <- p2
  kk <- kk+1
  
  ## max validation
  fit <- lm(f3, data=temp_maxvalid)
  dfstat$max_valid_KGE_slope[i] <- fit$coefficients[2]
  dfstat$max_valid_KGE_pvalue[i] <- summary(fit)$coefficients[2,4]
  xx <- as.numeric(unlist(temp_maxvalid[,variables_to_test[i]]))
  yy <- temp_maxvalid$kge_metric
  p3 <- data.frame("xx"=xx,"yy"=yy) %>% 
    ggplot(aes(xx,yy))+
    stat_summary(fun.data= mean_cl_normal) + 
    geom_smooth(method='lm')+
    xlab(variables_to_test[i])+
    ylab("Validation KGE")+
    ggtitle(sprintf("pvalue=%0.4g, slope=%0.4g",
                     dfstat$max_valid_KGE_pvalue[i], dfstat$max_valid_KGE_slope[i]))+
    theme(plot.title = element_text(size=6))
  plotlist[[kk]] <- p3
  kk <- kk+1
  
  # calibration consistency
  fit <- lm(f4, data=temp_perftbl)
  dfstat$calib_consistency_slope[i] <- fit$coefficients[2]
  dfstat$calib_consistency_KGE_pvalue[i] <- summary(fit)$coefficients[2,4]
}

write.csv(dfstat, "./results_data_tabulated/hydrologic_characteristic_results_2.csv",
          quote=FALSE,row.names=FALSE) 

# library(ggpubr)
# ggarrange(plotlist=plotlist,  ncol=3,nrow=length(variables_to_test), common.legend=FALSE) %>%
#   ggsave("regression_analysis_plot.pdf" ,
#                  plot=.,units="in", height=26, width=6.5)
```


```{r check regression of multiple variables on data}

# max calib KGE metric fits
fit <- lm(kge_metric ~ annual_average_precip_mm + annual_avg_streamflow_mm, data=temp_maxcalib)
summary(fit)

fit <- lm(kge_metric ~ annual_average_precip_mm + annual_average_PET_mm, data=temp_maxcalib)
summary(fit)

fit <- lm(kge_metric ~ evap_index + runoff_ratio, data=temp_maxcalib)
summary(fit)

fit <- lm(kge_metric ~ evap_index + runoff_ratio, data=temp_maxcalib)
summary(fit)


## validation gap fits
fit <- lm(validgap ~ annual_average_precip_mm + annual_avg_streamflow_mm, data=temp_validgap)
summary(fit)

fit <- lm(validgap ~ annual_average_precip_mm + annual_average_PET_mm, data=temp_validgap)
summary(fit)

fit <- lm(validgap ~ annual_average_precip_mm + annual_average_AET_mm, data=temp_validgap)
summary(fit)

fit <- lm(validgap ~ evap_index + runoff_ratio, data=temp_validgap)
summary(fit)

fit <- lm(validgap ~ lon + elevation_m + annual_avg_streamflow_mm, data=temp_validgap)
summary(fit)

variables_to_test

```
